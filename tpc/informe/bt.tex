Modelo: Tenemos un trie, le agregamos como clave el número prefijo. Como significado
el bill plan.

Explicar casos. Porque esos casos resuelven el problema (Agregar, completar, etc).

\subsection*{Solución}

El problema se define como el procesamiento de una tabla de planes de para los
prefijos de números telefónicos. Para modelar esto utilizamos un trie que toma como clave 
el número de prefijo y como significado el nombre del plan. 
La estructura del trie es basica: cada nodo tiene punteros a diez hijos, un char (Clave) y un
puntero a string (Significado).
Por otro lado tenemos un conjunto que contiene todos los bill plans que van apareciendo
de manera que nos simplifica la comparación entre los billing plans, debido a que 
nos permite realizar una comparación a nivel de punteros.

\subsection*{Detalles de implementación}

El algoritmo consta de 3 fases, la primera es el momento en que se van agregando los prefijos
al diccionario, la segunda donde se comprimen aquellos nodos que tienen a todos sus hijos
con el mismo billing plan, y por último la etapa donde se imprimen los prefijos resultantes 
del proceso.

En la primera etapa las inserciones pueden seguir 3 caminos posibles:
El primero es que al descender a través de la rama del árbol correspondiente, 
se encuentre con una hoja, con lo cual quiere decir que ya existe un plan que tiene definido
un código que es prefijo del que estamos tratando de insertar. En ese caso el algoritmo 
concluye en ese momento debido a que los códigos para este que está tratando de insertar ya están
ocupados.
El segundo camino es que en el momento del descenso intente definir un significado en un nodo que tiene
hijos. En este caso el algoritmo debe completar todos los nodos que corresponda tratando de expandirse
a través de todos los hijos que no estén completados. Esto quiere decir que también puede que tenga que completar 
la rama del hijo que contenía otro plan definido anteriormente.
El tercer camino posible es que al insertar llegue a una hoja sin que se haya cruzado con una hoja en el camino
y sin que tenga hijos el nodo donde se define el significado. En este caso sólo se realiza la inserción 
normal en el diccionario.

Para determinar dado un billing plan cual es el próximo código a insertar 
se realiza una iteración dentro del intervalo de los códigos definidos para el plan.
Pero para que no atraviese por todos los valores lo que hacemos es chequear si es que el siguiente
código termina con 0 y tratamos de reducir cortando el último caracter siempre que el 
código resultante no contenga ya algún otro código que tenga a este como prefijo. Repetimos el procedimiento
mientras se pueda y se realiza la inserción al nivel más alto posible del árbol.

En general durante el algoritmo tratamos los códigos como números enteros, avanzar de un código a otro lo realizamos 
como una suma. Esto trae la ventaja de que definir el tamaño original del intervalo de un plan dado (a,b) 
se puede computar como una suma entre los dígitos de b y a con los últimos k dígitos en 0, donde k es la cantidad de cifras de b.
Por otro lado surgió el problema de tener que trabajar con códigos que comienzan con dígitos en 0. 
Esto hizo que debamos a cada paso mantener contados los dígitos en 0 para el código actual y poder ubicarlo como prefijo al imprimirlo por ejemplo.


En la segunda fase realizamos la compresión del árbol. 
Para saber que un nodo se debe comprimir debe cumplir que todos sus hijos pertenezcan al mismos billing plan.
Entonces este proceso se puede realizar de manera recursiva con el fin de que en cada paso primero se hayan procesado
todos los hijos de un nodo y recién luego el mismo, así se tiene la certeza de que todos sus hijos fueron procesados
anteriormente. La recorrida a través del árbol se realiza mediante un DFS que retornará a un nodo el nombre del billing plan que 
comparten sus hijos si es que tal existe. La compresión se realiza en este paso debido a que no ofrece
ninguna ventaja realizarlo a medida que se realizan las inserciones porque si el nodo era candidato a comprimirse
ya estaba completo y no se iban a realizar otras inserciones en éste.

En la tercera y última fase se realiza la impresión de todos los códigos nuevos que se obtuvieron, que no es más que recorrer
todas las claves definidas en el diccionario e imprimirlas. Pero para lograr imprimir el número de líneas de la nueva tabla
mantenemos una variable que cuenta las claves definidas en cada momento del diccionario que no sean inválidas.
De esta manera cada vez que se agrega una clave se la incrementa en uno, mientras que cada vez que se comprime se la decrementa en 
nueve, ya que se borran diez hojas pero se inserta una.

Por último necesitamos utilizar long long int para poder guardar los prefijos que tenían una longitud máxima de 11 caracteres.
Debido a esto tuvimos que definir pasaje de long long int a char y viceversa,dado que atoi pasa a int. 
Lo mismo ocurrió con sprintf (de arreglo a un numero) y pow10 que por alguna razón no funcionaba correctamente. 

\subsection*{Análisis de complejidad}

Sea k el largo de las ramas del árbol y t el número de caracteres del alfabeto del árbol.


El orden de complejidad del algoritmo se puede determinar por cada una de las operaciones que realizamos
en cada fase. 

En la primera fase el algoritmo determinante es el de agregar un código. 
En la fase de inserción el debemos calcular la cantidad de ceros que tiene el código. 
El orden de éste es O(k). Luego este algoritmo va a ser utilizado durante toda la primera fase.

El caso en el que la inserción deviene en ingresar un único código el orden del algoritmo es O(k^2), 
que es la profundidad del árbol, que es la máxima cantidad de nodos que va a atravesar por el orden de cantidad de ceros.

En cambio cuando agregar un código se convierte en completar los niveles subsiguientes porque
el nodo que se intentaba definir es prefijo de uno ya existente, entonces se debe definir cada una de las ramas
de los hijos y explorarlas hacia abajo cuanto haga falta. El orden para el peor caso que se obtiene del algoritmo es 
O(k*t^k), que está dado por la profundidad de cada rama y la cantidad de hijos que puede tener un nodo y la cantidad de ceros.

Por último queda el caso donde la inserción se ve cortada porque no se llega a consumir toda la cadena a insertar 
y se encuentra un código definido antes. El orden para este caso se puede acotar por O(k^2), al igual que el primero.

En la segunda fase se realiza la compresión de las claves. El peor caso es donde el diccionario está definido en todas las hojas
de máxima profundidad con un mismo plan. En ese caso tiene que realizar un chequeo sobre cada uno de los nodos del árbol.
El orden al igual que el de completar es de O(t^k).

Por último queda la tercera fase que es la de recorrer todas las claves para poder imprimirlas.
Este tiene que pasar por todos los nodos del árbol por lo que el orden del mismo es O(t^k).
