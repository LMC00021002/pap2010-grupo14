El problema consiste en el procesamiento de una tabla de planes de facturación
para prefijos de números telefónicos. Para modelarlo utilizamos un trie
que toma como clave el número de prefijo, y como significado el nombre del
plan. Cada nodo tiene punteros a diez hijos, un puntero a string (significado)
y una clave.

El algoritmo consta de 3 fases: en la primera se agregan los prefijos al
diccionario, en la segunda se comprimen los nodos que tienen a todos sus hijos
con igual plan de facturación, y en la tercera se imprimen los prefijos
resultantes del proceso.

\subsubsection*{Inserción}

Las inserciones se pueden dividir en tres casos:

\begin{enumerate}
  \item Al descender a través de una rama correspondiente el algoritmo encuentra
  una hoja. Esto significa que ya existe un plan cuyo código es prefijo del
  que se intenta insertar. Los códigos necesarios para agregar el nuevo ya están
  ocupados, y se cancela la operación por falta de lugar.

  \item Descendiendo por una rama se intenta definir un significado en un nodo
  que tiene hijos. En este caso el algoritmo debe completar todos los nodos que
  corresponda, tratando de expandirse a través de todos los hijos que no
  estén completos.

  \item Al insertar se llega a una primer hoja, sin que tenga hijos el nodo
  donde se define el significado. En este caso se realiza la inserción ``normal''
  en el trie.
\end{enumerate}

\subsubsection*{Compresión}

En la segunda fase se comprime el árbol. Para poder comprimir un nodo, todos
sus hijos deben pertenecer al mismo plan de facturación. Lo chequeamos en
forma recursiva, procesando primero todos los hijos de un nodo, y luego a
él mismo. Se recorre el árbol via DFS, que retornará a un nodo el nombre
del plan que comparten sus hijos si existe uno único. Dado que no existe
ventaja en realizar la compresión a medida que se realizan las inserciones
(porque si el nodo era candidato a comprimirse estaba ya completo, y no
iba a tener nuevas inserciones), se comprime luego de todas las inserciones.

\subsubsection*{Impresión por pantalla}

En la tercera y última fase se realiza la impresión de los códigos procesados,
lo que se reduce a recorrer e imprimir todas las claves definidas en el
diccionario.

\subsection*{Detalles de implementación}

Dado un plan de facturación, para determinar el próximo código a insertar
se realiza una iteración dentro del intervalo de códigos definido para el
plan. Ya que tal vez no es necesario agregar todos los valores, se chequea
si el siguiente código termina con `0', y tratamos de reducir cortando el
último caracter siempre que el código resultante no contenga ya otro
código que tenga a este como prefijo. Repetimos el procedimiento mientras
se pueda, logrando ejecutar la inserción al nivel más alto posible en el árbol.

En general durante el algoritmo tratamos los códigos como números
enteros. Para avanzar de un código a otro se computa una suma. La ventaja es
que, dados $(a,b)$, definir el tamaño original del intervalo de un plan se
computa como una suma entre los dígitos de $b$ y $a$ con los últimos $k$
dígitos en 0, donde $k$ es la cantidad de cifras de $b$. Surgió con esto
el problema de trabajar con códigos que comiencen con ceros, debemos llevar
la cuenta de cuántos ceros tiene al inicio cada código, para ubicarlos
como prefijos al imprimir el árbol.

Por otro lado tenemos un conjunto que contiene todos los planes de
facturación que van apareciendo, lo que simplifica la comparación entre
planes de facturación, debido a que nos permite realizar comparaciones a
nivel de punteros.

Nos fue necesario utilizar {\tt long long int} para almacenar prefijos,
pues pueden tener una longitud máxima de 11 caracteres, números que no
entran en 32 bits. Debimos también definir el pasaje de {\tt long long int}
a {\tt char} y viceversa, dado que {\tt atoi} convierte de {\tt char} a {\tt
int}. Lo mismo ocurrió con {\tt sprintf} (de arreglo a número).

Para conocer (e imprimir) el número de líneas de la nueva tabla mantenemos
una variable que cuenta las claves definidas en cada momento que no sean
inválidas. Cada vez que se agrega una clave se la incrementa, mientras que
cuando se comprime se la decrementa en nueve (pues se borran diez hojas y
se inserta una).

% \begin{algorithm}[H]
% \linesnumbered
% \caption{artic\_point\_DFS($v,G$)}
% \Input{vértice $v$, grafo $G(V,E)$}

% \vspace{0.4cm}
% \For{$x$ tal que $\{v,x\} \in E$}{
%         \If{$x.dfs\_num = -1$}{
%                 $v.num\_children \gets v.num\_children+1$\;
%                 $stack.push(\{v,x\})$\;
%                 $artic\_point\_DFS(x,G)$
%         } \lElse{\If{$x.dfs\_num < v.dfs\_num - 1$}{
%                 $stack.push(\{v,x\})$\;
%         }}
% }
% \end{algorithm}

\subsection*{Análisis de complejidad}

Sea $k$ el largo de las ramas del árbol y $t$ el número de caracteres del alfabeto del árbol.

El orden de complejidad del algoritmo se puede determinar por cada una de las
operaciones que realizamos en cada fase. 

En la primera fase el algoritmo determinante es el de agregar un código. En la
fase de inserción el debemos calcular la cantidad de ceros que tiene el
código. El orden de éste es $O(k)$. Luego este algoritmo va a ser utilizado
durante toda la primera fase.

El caso en el que la inserción deviene en ingresar un único código el
orden del algoritmo es $O(k^2)$, que es la profundidad del árbol, que es la
máxima cantidad de nodos que va a atravesar por el orden de cantidad de ceros.

En cambio cuando agregar un código se convierte en completar los niveles
subsiguientes porque el nodo que se intentaba definir es prefijo de uno ya
existente, entonces se debe definir cada una de las ramas de los hijos y
explorarlas hacia abajo cuanto haga falta. El orden para el peor caso que se
obtiene del algoritmo es $O(k*t^k)$, que está dado por la profundidad de cada
rama y la cantidad de hijos que puede tener un nodo y la cantidad de ceros.

Por último queda el caso donde la inserción se ve cortada porque no
se llega a consumir toda la cadena a insertar y se encuentra un código
definido antes. El orden para este caso se puede acotar por $O(k^2)$, al igual
que el primero.

En la segunda fase se realiza la compresión de las claves. El peor caso es
donde el diccionario está definido en todas las hojas de máxima profundidad
con un mismo plan. En ese caso tiene que realizar un chequeo sobre cada uno
de los nodos del árbol. El orden al igual que el de completar es de $O(t^k)$.

Por último queda la tercera fase que es la de recorrer todas las claves para
poder imprimirlas. Este tiene que pasar por todos los nodos del árbol, por lo
que su orden es $O(t^k)$.
