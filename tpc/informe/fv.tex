\subsection*{Solución}

Dada una secuencia $A$ de números no decrecientes, y un conjunto de pares $(i,j)$
(con $|A|=n$, $1 \le i \le j \le n$), el problema consiste en encontrar la cantidad
de veces que aparece el valor más frecuente en $A$ entre el intervalo $(i,j)$
de índices de cada consulta.

Para solucionar el problema decidimos usar el algoritmo {\sl Range Minimum Query}
(RMQ), pero una aplicación directa de este algoritmo para este problema no es posible,
pues RMQ encuentra un mínimo de una secuencia de números en un rango acotado dado, y nosotros
necesitamos un máximo, pero además este máximo no es un entero de la secuencia,
sino la cantidad de ocurrencias de un número. Como vemos, por lo tanto, una aplicación
directa del algoritmo no es posible, pues no resolvería el problema.

Procesamos los datos de entrada del problema de modo de poder obtener la
respuesta ejecutando {\sl Range Minimum Query}. RMQ indica el valor máximo o
mínimo entre dos índices de un arreglo, pero lo que necesitamos es conocer la
frecuencia con que aparece el más frecuente en ese rango. Para encontrarla,
generamos un arreglo tal que buscar el máximo entre los $i$ y $j$ de cada
consulta mediante RMQ sea la respuesta al problema.

\subsection*{Detalles de implementación}

Definimos para preprocesar los datos de la entrada las siguientes estructuras:

\begin{itemize}
  \item[\tt enteros] tiene largo $k$, siendo $k$ el número de elementos
  distintos en $A$. En cada posición $i$ se almacena la cantidad de apariciones
  del iésimo elemento (distinto) de $A$.

  \item[\tt rangos] es un vector que contiene pares cuyos elementos denotan
  los índices de los subarreglos maximales de elementos iguales en $A$.

  \item[\tt mapIndices] es un diccionario sobre {\tt map}, que, dada una
  posición de $A$, indica la posición correspondiente en {\tt enteros}. Esto es:
  {\tt mapIndices[$j$]}$=i \Leftrightarrow A[j]$ contiene al iésimo elemento
  distinto.

  \item[\tt tabla] es la tabla RMQ (implementada sobre vectores de vectores).
  La obtenemos a partir del arreglo {\tt enteros} mediante el algoritmo {\sl
  Sparse Table}. Este algoritmo mantiene un arreglo $M[0,N-1][0,\log N]$,
  siendo $M[i][j]$ el índice del valor mínimo en el subarreglo que empieza en
  $i$ de largo $2j$. [Seguir explicando.] \cite{topcoder}
\end{itemize}

Dada una consulta $(i,j)$, computamos en qué rango cae cada índice (vector
{\tt rangos}). Si un mismo rango contiene a ambos, entonces la consulta ``encierra''
a un conjunto de elementos iguales, por lo que el valor más frecuente es ese y
su cantidad de apariciones es $j-i$. Si $i$ y $j$ pertenencen a rangos distintos
(llamamos a esos rangos $S$ y $T$), debemos encontrar la frecuencia del valor más
frecuente en $S,T$, y en los rangos $R_i$ que queden contenidos completamente
entre $S$ y $T$ (posiblemente ninguno). Dicha frecuencia se computa para $S$ y
$T$ en $O(1)$ [explicar aritmética], y el máximo entre todos los intervalos $R_i$
se obtiene ejecutando RMQ sobre el arreglo {\tt enteros}. La respuesta al
problema es entonces el máximo entre los tres valores así obtenidos.

\subsection*{Análisis de complejidad}

[Completar.]

\bibliographystyle{acm}
\bibliography{citas}
