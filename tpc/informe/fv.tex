\subsection*{Solución}

Dada una secuencia $A$ de números no decrecientes, y un conjunto de pares $(i,j)$
(con $|A|=n$, $1 \le i \le j \le n$), el problema consiste en encontrar la
cantidad de veces que aparece el valor más frecuente en $A$ entre el intervalo
$(i,j)$ de índices de cada consulta.

Para solucionar el problema decidimos usar el algoritmo {\sl Range Minimum Query}
(RMQ) visto en clase, pero una aplicación directa de este algoritmo para este problema
no es posible, pues RMQ encuentra un mínimo de una secuencia de números en un rango
acotado dado, y nosotros necesitamos un máximo, pero además este máximo no es
un entero de la secuencia, sino la cantidad de ocurrencias de un número.
Como vemos, por lo tanto, aplicar RMQ al input no resolvería el problema.

Adaptar el {\sl Range Minimum Query} a un {\sl Range Maximum Query} es simple
y es un detalle de implementación que será explicado luego. Por ahora asumamos
que podemos calcular el {\sl Range Maximum Query}.

Para adaptar la secuencia que nos provee el input la recorremos de forma
lineal compactando los enteros que son iguales y consecutivos por un entero
estrictamente mayor a $0$ que representa la cantidad de repeticiones de ese
entero en la secuencia original (se asegura que todos los enteros repetidos
aparecen de forma consecutiva ya que la secuencia viene ordenada).

Notar que la secuencia $s_t$ que resulta de transformar la secuencia $s$ tiene
una longitud $1 \le L_{s_t} \le L_s$. Por lo tanto, los índices del intervalo $(i,j)$
de la query del input pueden ser de valor mayor a $L_{s_t}$, por lo que necesitamos
una forma de mapear estos índices por índices de nuestra secuencia. Para esto
definimos un mapeo que dado un índice $i$, $mapIndice(i) = k$ es un índice de $s_t$
con $k <= L_{s_t}$, donde $s_{t_k}$ es la cantidad de veces que ocurre el elemento
$s_i$ en la secuencia $s$.

Dada esta transformación, es tentador utilizar RMQ directamente sobre $s_t$, pero
esto no resuelve el problema, pues, por ejemplo, para el input del enunciado
$s = [-1, -1, 1, 1, 1, 1, 3, 10, 10, 10]$, $s_t = [2, 4, 1, 3]$, y supongamos
que nos dan la query $q = (2, 3)$, entonces $mapIndice(2) = 1$ y $mapIndice(3) = 2$,
por lo tanto $RMQ_{s_t}(1,2) = 4$, que sería lo que devolvemos si no hacemos nada más,
pero este resultado es incorrecto, pues debíamos devolver $1$. Esto se debe a que
los intervalos de antes que tenían una longitud y que permite hacer querys con indices
que caen entremedio se fusionaron en un solo entero.

Por lo tanto necesitamos una forma de solucionar esto último, y lo hacemos definiendo
otra función auxiliar $mapRangos(i) = <k_1, k_2>$, donde $1 \le k_1 \le k_2 \le L_s$
y $k_1$ es el índice donde comienza a ocurrir el elemento $s_i$ y $k_2$ es el índice
de la última ocurrencia del mismo elemento en la secuencia original $s$.

Con todo esto hecho, tenemos todas las herramientas necesarias para el cálculo de
la solución. Dado un $s_t$ transformado de $s$ y una query $q = (i, j)$, tenemos una
secuencia de rangos $<k_{1_1}, k_{1_2}>, <k_{2_1}, k_{2_2}>, ..., <k_{m_1}, k_{m_2}>$
siendo $m = L_{s_t}$, y sabemos que $mapRangos(i) = <k_{p_1}, k_{p_2}>$ con
$p = mapIndice(i)$ y $mapRangos(j) = <k_{r_1}, k_{r_2}>$ con $r = mapIndice(j)$, $p \le r$.
Por lo tanto la función que calcula el resultado será:
\[ FV(s, i, j) = \left\{ \begin{array}{ll}
                 $j - i + 1$ & \mbox{si $p = r$}\\
                 $max( k_{p_2} - i + 1, j - k_{r_1} + 1, RMQ_{s_t}(p + 1, r - 1) )$ & \mbox{si $p < r$}.\end{array} \right \] 

\subsection*{Detalles de implementación}

Definimos para preprocesar los datos de la entrada las siguientes estructuras:

\begin{itemize}
  \item[\tt enteros] tiene largo $k$, siendo $k$ el número de elementos
  distintos en $A$. En cada posición $i$ se almacena la cantidad de apariciones
  del iésimo elemento (distinto) de $A$.

  \item[\tt rangos] es un vector que contiene pares cuyos elementos denotan
  los índices de los subarreglos maximales de elementos iguales en $A$.

  \item[\tt mapIndices] es un diccionario sobre {\tt map}, que, dada una
  posición de $A$, indica la posición correspondiente en {\tt enteros}. Esto es:
  {\tt mapIndices[$j$]}$=i \Leftrightarrow A[j]$ contiene al iésimo elemento
  distinto.

  \item[\tt tabla] es la tabla RMQ (implementada sobre vectores de vectores).
  La obtenemos a partir del arreglo {\tt enteros} mediante el algoritmo {\sl
  Sparse Table}. Este algoritmo mantiene un arreglo $M[0,N-1][0,\log N]$,
  siendo $M[i][j]$ el índice del valor mínimo en el subarreglo que empieza en
  $i$ de largo $2j$. [Seguir explicando.] \cite{topcoder}
\end{itemize}

Dada una consulta $(i,j)$, computamos en qué rango cae cada índice (vector
{\tt rangos}). Si un mismo rango contiene a ambos, entonces la consulta ``encierra''
a un conjunto de elementos iguales, por lo que el valor más frecuente es ese y
su cantidad de apariciones es $j-i$. Si $i$ y $j$ pertenencen a rangos distintos
(llamamos a esos rangos $S$ y $T$), debemos encontrar la frecuencia del valor más
frecuente en $S,T$, y en los rangos $R_i$ que queden contenidos completamente
entre $S$ y $T$ (posiblemente ninguno). Dicha frecuencia se computa para $S$ y
$T$ en $O(1)$ [explicar aritmética], y el máximo entre todos los intervalos $R_i$
se obtiene ejecutando RMQ sobre el arreglo {\tt enteros}. La respuesta al
problema es entonces el máximo entre los tres valores así obtenidos.

\subsection*{Análisis de complejidad}

[Completar.]

\bibliographystyle{acm}
\bibliography{citas}
