\subsection*{Solución}

Dada una secuencia $A$ de números no decrecientes, y un conjunto de pares $(i,j)$
(con $|A|=n$, $1 \le i \le j \le n$), el problema consiste en encontrar la
cantidad de veces que aparece el valor más frecuente en $A$ entre el intervalo
$(i,j)$ de índices de cada consulta.

Para solucionar el problema decidimos usar el algoritmo {\sl Range Minimum consulta}
(RMQ) visto en clase, pero una aplicación directa de dicho algoritmo para este problema
no es posible, pues RMQ encuentra un mínimo de una secuencia de números en un rango
acotado dado, y nosotros necesitamos un máximo, pero además este máximo no es
un entero de la secuencia, sino la cantidad de ocurrencias de un número.
Como vemos, aplicar RMQ al input no resolvería el problema.

Adaptar el {\sl Range Minimum consulta} a un {\sl Range Maximum consulta} es simple
y es un detalle de implementación que será explicado luego. Por ahora asumamos
que podemos calcular el {\sl Range Maximum consulta}.

Para adaptar la secuencia que nos provee el input la recorremos de forma
lineal compactando los enteros que son iguales y consecutivos por un entero
estrictamente mayor a $0$, que representa la cantidad de repeticiones de ese
entero en la secuencia original (sabemos que todos los enteros repetidos
aparecen de forma consecutiva porque la secuencia viene ordenada).

Notar que para la secuencia $s_t$ que resulta de transformar la secuencia $s$ vale
que $1 \le |s_t| \le |s|$. Por lo tanto, los índices del intervalo $(i,j)$
de la consulta del input pueden ser de valor mayor a $|s_t|$, por lo que necesitamos
una forma de mapear estos índices por índices de nuestra secuencia. Para esto
definimos $mapIndice$, que dado un índice de $A$, indica la posición correspondiente
en $s_t$ (llamémosla $k$), donde $s_{t_k}$ es la cantidad de veces que ocurre el
elemento $s_i$ en la secuencia $s$.

Dada esta transformación, es tentador utilizar RMQ directamente sobre $s_t$, pero
esto no resuelve el problema, pues una consulta podría ``partir'' intervalos.
Por ejemplo, para el input del enunciado
($s = [-1, -1, 1, 1, 1, 1, 3, 10, 10, 10]$, $s_t = [2, 4, 1, 3]$) y la consulta
$q=(2,3)$, $mapIndice(2) = 1$ y $mapIndice(3) = 2$, por lo tanto $RMQ_{s_t}(1,2)
=4$. Pero este resultado es incorrecto, pues debíamos devolver $1$, teniendo en
cuenta que no se seleccionan los intervalos completos.

Para solucionar esto, definimos la función auxiliar $mapRangos(i) = <k_1,k_2>$,
donde $1 \le k_1 \le k_2 \le L_s$ y $k_1$ es el índice de la primera aparición
del elemento $s_i$ en $s$, y $k_2$ es el índice de la última aparición de $s_i$ en $s$.

Ahora tenemos todas las estructuras necesarias para calcular la solución. Dado
un $s_t$ transformado de $s$ y una consulta $q = (i, j)$, tenemos una
secuencia de rangos $<k_{1_1}, k_{1_2}>, <k_{2_1}, k_{2_2}>, \ldots, <k_{m_1}, k_{m_2}>$
siendo $m = |s_t|$, y sabemos que $mapRangos(i) = <k_{p_1}, k_{p_2}>$ con
$p = mapIndice(i)$ y $mapRangos(j) = <k_{r_1}, k_{r_2}>$ con $r = mapIndice(j)$, $p \le r$.
La función que calcula el resultado será:

\[ FV(s, i, j) = \left\{ \begin{array}{ll}
                 j - i + 1 & \mbox{si $p = r$};\\
                 max\{ k_{p_2} - i + 1, j - k_{r_1} + 1, RMQ_{s_t}(p_2 + 1, r_1 - 1) \} & \mbox{si $p < r$}.\end{array} \right. \]
     
Intuitivamente esta función corre RMQ para todos los intervalos completos
que hay entre $i$ y $j$, y computa en forma particular el máximo de los
intervalos que quedan ``cortados'' por los índices, devolviendo como solución al
problema el máximo de los tres valores obtenidos.


\subsection*{Detalles de implementación}

Definimos para preprocesar los datos de la entrada las siguientes estructuras:

\begin{itemize}
  \item[\tt enteros] tiene largo $k$, siendo $k$ el número de elementos
  distintos en $A$. En cada posición $i$ se almacena la cantidad de apariciones
  del iésimo elemento (distinto) de $A$.

  \item[\tt rangos] es un vector que contiene pares cuyos elementos denotan
  los índices de los subarreglos maximales de elementos iguales en $A$.

  \item[\tt mapIndices] es un diccionario sobre {\tt map}, que, dada una
  posición de $A$, indica la posición correspondiente en {\tt enteros}. Esto es:
  {\tt mapIndices[$j$]}$=i \Leftrightarrow A[j]$ contiene al iésimo elemento
  distinto.

  \item[\tt tabla] es la tabla RMQ (implementada sobre vectores de vectores).
  La obtenemos a partir del arreglo {\tt enteros} mediante el algoritmo {\sl
  Sparse Table}. Este algoritmo mantiene un arreglo $M[0,N-1][0,\log N]$,
  siendo $M[i][j]$ el índice del valor mínimo en el subarreglo que empieza en
  $i$ de largo $2j$. [Seguir explicando.] \cite{topcoder}
\end{itemize}

Dada una consulta $(i,j)$, computamos en qué rango cae cada índice (vector
{\tt rangos}). Si un mismo rango contiene a ambos, entonces la consulta ``encierra''
a un conjunto de elementos iguales, por lo que el valor más frecuente es ese y
su cantidad de apariciones es $j-i$. Si $i$ y $j$ pertenencen a rangos distintos
(llamamos a esos rangos $S$ y $T$), debemos encontrar la frecuencia del valor más
frecuente en $S,T$, y en los rangos $R_i$ que queden contenidos completamente
entre $S$ y $T$ (posiblemente ninguno). Dicha frecuencia se computa para $S$ y
$T$ en $O(1)$ [explicar aritmética], y el máximo entre todos los intervalos $R_i$
se obtiene ejecutando RMQ sobre el arreglo {\tt enteros}. La respuesta al
problema es entonces el máximo entre los tres valores así obtenidos.

\subsection*{Análisis de complejidad}

[Completar.]

\bibliographystyle{acm}
\bibliography{citas}
