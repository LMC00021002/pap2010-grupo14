El problema consiste en el procesamiento de una tabla de planes de facturación
para prefijos de números telefónicos. Para modelarlo utilizamos un trie
que toma como clave el número de prefijo, y como significado el nombre del
plan. Cada nodo tiene punteros a diez hijos, un puntero a string (significado)
y una clave.

El algoritmo consta de 3 fases: en la primera se agregan los prefijos al
diccionario, en la segunda se comprimen los nodos que tienen a todos sus hijos
con igual plan de facturación, y en la tercera se imprimen los prefijos
resultantes del proceso.

\subsubsection*{Inserción}

Las inserciones se pueden dividir en tres casos:

\begin{enumerate}
  \item Al descender a través de una rama correspondiente el algoritmo encuentra
  una hoja. Esto significa que ya existe un plan cuyo código es prefijo del
  que se intenta insertar. Los códigos necesarios para agregar el nuevo ya están
  ocupados, y se cancela la operación por falta de lugar.

  \item Descendiendo por una rama se intenta definir un significado en un nodo
  que tiene hijos. En este caso el algoritmo debe completar todos los nodos que
  corresponda, tratando de expandirse a través de todos los hijos que no
  estén completos.

  \item Al insertar se llega a una primer hoja, sin que tenga hijos el nodo
  donde se define el significado. En este caso se realiza la inserción ``normal''
  en el trie.
\end{enumerate}

\subsubsection*{Compresión}

En la segunda fase se comprime el árbol. Para poder comprimir un nodo, todos
sus hijos deben pertenecer al mismo plan de facturación. Lo chequeamos en
forma recursiva, procesando primero todos los hijos de un nodo, y luego a
él mismo. Se recorre el árbol via DFS, que retornará a un nodo el nombre
del plan que comparten sus hijos si existe uno único. Dado que no existe
ventaja en realizar la compresión a medida que se realizan las inserciones
(porque si el nodo era candidato a comprimirse estaba ya completo, y no
iba a tener nuevas inserciones), se comprime luego de todas las inserciones.

\subsubsection*{Impresión por pantalla}

En la tercera y última fase se realiza la impresión de los códigos procesados,
lo que se reduce a recorrer e imprimir todas las claves definidas en el
diccionario.

\subsection*{Detalles de implementación}

Dado un plan de facturación, para determinar el próximo código a insertar se
itera en el intervalo que define. Ya que puede no ser necesario agregar todos
los valores, se chequea si el siguiente código termina con `0', y tratamos
de reducir cortando el último caracter siempre que el código resultante no
contenga a otro código distinto (que tiene a este como prefijo). Repetimos el
procedimiento mientras se pueda, logrando insertar al nivel más alto posible en
el árbol.

Guardamos en un {\tt set} todos los planes de facturación a procesar, lo que
simplifica la comparación entre planes, reducida a comparar punteros.

Durante la mayor parte del algoritmo tratamos a los códigos como números
enteros. Dado un plan $a-b$, $k=|b|$, definir el tamaño original del
intervalo se computa poniendo en cero los últimos $k$ dígitos de $a$,
y haciendo $a+b$. Pero un código podría tener ceros como prefijo, para
tenerlos en cuenta se lo lee primero como string, se cuenta la cantidad de
ceros al inicio, y se los agrega como prefijo al momento de imprimir el árbol.

Fue necesario utilizar {\tt long long int} para almacenar prefijos,
pues pueden tener una longitud máxima de 11 caracteres, números que no
entran en 32 bits. Debimos definir el pasaje de {\tt long long int} a {\tt char}
y viceversa.

Para conocer el número de líneas de la nueva tabla mantenemos un contador
de claves definidas y que no sean inválidas. Cuando se agrega una nueva
clave se la incrementa, y al comprimir un nodo se la decrementa en nueve
(pues en ese proceso se eliminan diez hojas y se agrega una).

\subsection*{Análisis de complejidad}

Sea $k$ el largo de las ramas del árbol y $t$ el número de caracteres del alfabeto del árbol.

El orden de complejidad del algoritmo se puede determinar por cada una de las
operaciones que realizamos en cada fase. 

En la primera fase el algoritmo determinante es el de agregar un código. En la
fase de inserción el debemos calcular la cantidad de ceros que tiene el
código. El orden de éste es $O(k)$. Luego este algoritmo va a ser utilizado
durante toda la primera fase.

El caso en el que la inserción deviene en ingresar un único código el
orden del algoritmo es $O(k^2)$, que es la profundidad del árbol, que es la
máxima cantidad de nodos que va a atravesar por el orden de cantidad de ceros.

En cambio cuando agregar un código se convierte en completar los niveles
subsiguientes porque el nodo que se intentaba definir es prefijo de uno ya
existente, entonces se debe definir cada una de las ramas de los hijos y
explorarlas hacia abajo cuanto haga falta. El orden para el peor caso que se
obtiene del algoritmo es $O(k*t^k)$, que está dado por la profundidad de cada
rama y la cantidad de hijos que puede tener un nodo y la cantidad de ceros.

Por último queda el caso donde la inserción se ve cortada porque no
se llega a consumir toda la cadena a insertar y se encuentra un código
definido antes. El orden para este caso se puede acotar por $O(k^2)$, al igual
que el primero.

En la segunda fase se realiza la compresión de las claves. El peor caso es
donde el diccionario está definido en todas las hojas de máxima profundidad
con un mismo plan. En ese caso tiene que realizar un chequeo sobre cada uno
de los nodos del árbol. El orden al igual que el de completar es de $O(t^k)$.

Por último queda la tercera fase que es la de recorrer todas las claves para
poder imprimirlas. Este tiene que pasar por todos los nodos del árbol, por lo
que su orden es $O(t^k)$.
